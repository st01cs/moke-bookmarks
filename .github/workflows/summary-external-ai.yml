name: Summarize new issues (External AI)
run-name: Summarize ${{ github.event.issue.title }}[${{ github.event.issue.number }}] with external AI

on:
  issues:
    types: [opened]

env:
  SUMMARY_LANGUAGE: ${{ vars.SUMMARY_LANGUAGE || 'cn' }}
  AI_MODEL: ${{ vars.AI_MODEL }}
  AI_MAX_TOKENS: ${{ vars.AI_MAX_TOKENS || '2000' }}
  AI_BASE_URL: ${{ vars.AI_BASE_URL }}

jobs:
  summary:
    runs-on: ubuntu-latest
    if: ${{ vars.AI_MODEL != '' && vars.AI_BASE_URL != '' }}
    permissions:
      issues: write
      contents: read

    services:
      crawl4ai:
        image: unclecode/crawl4ai:0.7.3
        ports:
          - 11235:11235
        options: --shm-size=1g

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
      
      - name: Validate URL format
        id: urlValidation
        run: |
          URL="${{ github.event.issue.body }}"
          if [[ $URL =~ ^https?:// ]]; then
            echo "valid=true" >> $GITHUB_OUTPUT
            echo "url=$URL" >> $GITHUB_OUTPUT
          else
            echo "valid=false" >> $GITHUB_OUTPUT
            echo "URL validation failed: '$URL' is not a valid HTTP/HTTPS URL"
          fi
      
      - name: Wait for Crawl4AI service
        run: |
          for i in {1..30}; do
            if curl -s -f http://localhost:11235/health >/dev/null 2>&1; then
              echo "Crawl4AI service is ready"
              exit 0
            fi
            echo "Waiting for Crawl4AI service... (attempt $i/30)"
            sleep 2
          done
          echo "Warning: Crawl4AI service may not be fully ready"

      - name: Submit crawl job to Crawl4AI
        id: crawlSubmit
        if: steps.urlValidation.outputs.valid == 'true'
        run: |
          # Create optimized JSON payload for better content extraction
          cat > /tmp/crawl_payload.json << 'JSON_EOF'
          {
            "urls": ["${{ steps.urlValidation.outputs.url }}"],
            "priority": 10,
            "crawler_params": {
              "user_agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/122.0.0.0 Safari/537.36",
              "page_timeout": 60000,
              "delay_before_return_html": 2000,
              "wait_for": "body",
              "markdown_generator": {
                "type": "DefaultMarkdownGenerator",
                "options": {
                  "ignore_links": false,
                  "ignore_images": false,
                  "excluded_tags": ["script", "style", "nav", "header", "footer", "aside", "form", "iframe", "noscript", "svg", "canvas", "audio", "video", "embed", "object"],
                  "word_count_threshold": 10,
                  "keep_data_attributes": false,
                  "body_only": true
                }
              },
              "content_filter": {
                "type": "PruningContentFilter",
                "threshold": 0.48,
                "threshold_type": "fixed",
                "min_word_threshold": 20
              },
              "extraction_strategy": {
                "type": "NoExtractionStrategy"
              },
              "chunking_strategy": {
                "type": "RegexChunking",
                "patterns": ["\n\n", "\n", "\. "],
                "chunk_size": 1000,
                "overlap": 200
              },
              "cache_mode": "bypass"
            }
          }
          JSON_EOF
          
          # Submit the request with curl for better control
          RESPONSE=$(curl -s -X POST \
            -H "Content-Type: application/json" \
            -d @/tmp/crawl_payload.json \
            --connect-timeout 10 \
            --max-time 60 \
            http://localhost:11235/crawl)
          
          echo "Raw response: $RESPONSE"
          
          # Write response to temp file for next step
          echo "$RESPONSE" > /tmp/crawl_submit_response.json
          
          # Check if response contains success indicator
          if echo "$RESPONSE" | grep -q '"success".*true\|"task_id"\|"id"\|"results"'; then
            echo "Crawl job submitted successfully"
            echo "response=$RESPONSE" >> $GITHUB_OUTPUT
          else
            echo "Warning: Crawl job submission may have failed"
            echo "response=$RESPONSE" >> $GITHUB_OUTPUT
          fi
        continue-on-error: true

      - name: Wait for crawl completion
        id: crawlResult
        if: steps.crawlSubmit.outcome == 'success' && steps.crawlSubmit.outputs.response != ''
        run: |
          # Write response to temp file using cat with heredoc to avoid shell escaping issues
          cat > /tmp/crawl_submit_response.json << 'RESPONSE_EOF'
          ${{ steps.crawlSubmit.outputs.response }}
          RESPONSE_EOF
          # Execute the Python script
          python3 scripts/wait_crawl.py
        continue-on-error: true

      - name: Determine prompt file
        id: promptFile
        run: |
          if [[ "${{ env.SUMMARY_LANGUAGE }}" == "en" ]]; then
            echo "summary-file=./.github/prompts/summary-system-en.txt" >> $GITHUB_OUTPUT
            echo "keywords-file=./.github/prompts/keywords-system-en.txt" >> $GITHUB_OUTPUT
          else
            echo "summary-file=./.github/prompts/summary-system-cn.txt" >> $GITHUB_OUTPUT
            echo "keywords-file=./.github/prompts/keywords-system-cn.txt" >> $GITHUB_OUTPUT
          fi

      - name: Rate limiting delay
        run: sleep 2

      - name: Truncate content for token limit
        id: truncateContent
        run: |
          # Write crawl result response to temp file to avoid environment variable length limits
          cat > /tmp/crawl_result_response.json << 'RESULT_EOF'
          ${{ steps.crawlResult.outputs.response }}
          RESULT_EOF
          # Execute the Python script
          python3 scripts/truncate_content.py
        env:
          CRAWL_OUTCOME: ${{ steps.crawlResult.outcome }}
          FALLBACK_URL: ${{ github.event.issue.body }}
          FALLBACK_TITLE: ${{ github.event.issue.title }}
          TRUNCATE_CONTENT_MAX_LENGTH: ${{ vars.TRUNCATE_CONTENT_MAX_LENGTH }}

      - name: Install Python dependencies
        run: |
          python3 -m pip install --upgrade pip
          python3 -m pip install requests

      - name: Run AI inference for summary
        id: inference
        run: |
          echo "${{ steps.truncateContent.outputs.content }}" | python3 scripts/ai_inference.py
        env:
          AI_API_KEY: ${{ secrets.AI_API_KEY }}
          AI_BASE_URL: ${{ env.AI_BASE_URL }}
          AI_MODEL: ${{ env.AI_MODEL }}
          AI_MAX_TOKENS: ${{ env.AI_MAX_TOKENS }}
          SYSTEM_PROMPT_FILE: ${{ steps.promptFile.outputs.summary-file }}
          USER_PROMPT: ${{ steps.truncateContent.outputs.content }}

      - name: Comment with AI summary
        run: |
          # Write AI response to temp file to handle special characters
          cat > /tmp/ai_summary_response.txt << 'SUMMARY_EOF'
          ${{ steps.inference.outputs.response }}
          SUMMARY_EOF
          # Use Python script to post comment safely
          python3 scripts/post_comment.py /tmp/ai_summary_response.txt $ISSUE_NUMBER
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          ISSUE_NUMBER: ${{ github.event.issue.number }}
          
      - name: Run AI inference for keywords
        id: inference-keywords
        run: |
          echo "${{ steps.truncateContent.outputs.content }}" | python3 scripts/ai_inference.py
        env:
          AI_API_KEY: ${{ secrets.AI_API_KEY }}
          AI_BASE_URL: ${{ env.AI_BASE_URL }}
          AI_MODEL: ${{ env.AI_MODEL }}
          AI_MAX_TOKENS: 100
          SYSTEM_PROMPT_FILE: ${{ steps.promptFile.outputs.keywords-file }}
          USER_PROMPT: ${{ steps.truncateContent.outputs.content }}
  
      - name: Comment with AI keywords
        run: |
          # Write AI response to temp file to handle special characters
          cat > /tmp/ai_keywords_response.txt << 'KEYWORDS_EOF'
          ${{ steps.inference-keywords.outputs.response }}
          KEYWORDS_EOF
          # Use Python script to post comment safely
          python3 scripts/post_comment.py /tmp/ai_keywords_response.txt $ISSUE_NUMBER
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          ISSUE_NUMBER: ${{ github.event.issue.number }}